*********************************************************************************************************
Instalacja Pythona oraz IDE (Integrated Development Environment)
*********************************************************************************************************

1. https://www.python.org/downloads/

2. Wybierz edytor kodu, który będzie wygodny do pisania i uruchamiania skryptów Pythona. 
   Popularne opcje to:
   - Visual Studio Code (VS Code)
   - PyCharm
   - Sublime Text


*********************************************************************************************************
Pierwszy skrypt w Pythonie
*********************************************************************************************************

Otwórz wybrany edytor kodu (np. VS Code) i utwórz nowy plik z rozszerzeniem .py. Wpisz poniższy kod, aby wyświetlić "Hello, World!": 

print("Hello, World!")

Zapisz plik i uruchom go. W VS Code możesz to zrobić, klikając prawym przyciskiem myszy na plik i wybierając "Run Python File in Terminal".

*********************************************************************************************************
Dodatkowe narzędzia programistyczne
*********************************************************************************************************

FastAPI – lekki i szybki framework do budowy API w Pythonie.
Uvicorn – lekki i szybki serwer ASGI, idealny do uruchamiania aplikacji FastAPI.

*********************************************************************************************************
Uruchomienie serwera
*********************************************************************************************************

python -m uvicorn main:app --reload
- Uruchamianie modułu uvicorn

python -m 
- Polecenie uruchomienia modułu w Pythonie

main:app
- Odniesienie do aplikacji, którą chcemy uruchomić (main to nazwa utworzonego wcześniej pliku, bez rozszerzenia .py)

app
- Instancja aplikacji 

*********************************************************************************************************
Konfiguracja połączenia z bazą danych, CRUD
*********************************************************************************************************

1. Zainstaluj:
- sqlalchemy (ORM - mapowanie obiektowo-relacyjne),
- geoalchemy2 (do integracji z bazą danych przestrzennych),
- pydantic (do walidacji danych wejściowych),
- shapely (do zarządzania danymi geoprzestrzennymi oraz do analiz geoprzestrzennych).

2. Skonfiguruj połączenie z bazą danych (w nowym pliku db_config.py)
from sqlalchemy.orm import sessionmaker, declarative_base
from sqlalchemy import create_engine

# W przypadku łączenia z bazą PostgreSQL
DATABASE_URL = "postgresql://<db_user_name>:<db_user_password>@localhost:5432/<db_name>"
# W przypadku łączenia z bazą SQlite
DATABASE_URL = "sqlite:///./<db_file_name.db>"

# Wariant A (PostgreSQL): Inicjalizacja silnika bazy danych (engine), który będzie używany przez SQLAlchemy
db_engine = create_engine(DATABASE_URL)
# Wariant B (SQLite): Dla SQLite warto ustawić `check_same_thread=False`, bo inaczej mogą być błędy przy pracy z FastAPI
db_engine = create_engine(DATABASE_URL, connect_args={"check_same_thread": False}) # Silniki t.j. PostgreSQL są domyślnie wielowątkowe, dlatego flaga check_same_thread ich nie dotyczy
# Konfiguracja sesji do komunikacji z bazą danych (z wykorzystaniem wzorca Factory)
DBSession = sessionmaker(
    autocommit=False,  # nie zatwierdzaj automatycznie transakcji
    autoflush=False,   # nie wysyłaj danych do bazy przed .commit()
    bind=db_engine     # połącz z daną bazą za pomocą silnika (engine)
)
# Definicja bazowej klasy do deklarowania modeli ORM
ORMBaseModel = declarative_base()

# Funkcja pomocniczna do zarządzania sesją
def get_db_session():
    db_session = DBSession()
    try:
        yield db_session 
    finally:
        db_session.close() # Zamknięcie sesji po zakończeniu zapytania

3. Zgodnie z wybraną tematyką projektu, zdefiniuj model reprezentujący zasób, którym chcesz zarządzać (w nowym pliku models.py)
from sqlalchemy import Column, Integer, String
from sqlalchemy.orm import Mapped
from db_config import ORMBaseModel
from pydantic import BaseModel

# Zastąp swoimi modelami:

class Person(ORMBaseModel):
    __tablename__ = 'person'
    id = Column(Integer, primary_key=True, index=True)
    first_name = Column(String)
    last_name = Column(String)
    person_type_id = Column(Integer, index=True)
    position = Column(String)

from pydantic import BaseModel

class PersonCreate(BaseModel):
    first_name: str
    last_name: str
    person_type_id: int
    position: str

    class Config:
        arbitrary_types_allowed = True

class PositionUpdate(BaseModel):
    position: str

    class Config:
        arbitrary_types_allowed = True

4. main.py
# Importy 
from models import Person, PersonCreate, PositionUpdate
from db_config import ORMBaseModel
from fastapi import FastAPI, HTTPException, Depends
from db_config import db_engine, get_db_session
from sqlalchemy.orm import Session
from shapely import wkb

# Utworzenie tabel w bazie, jeśli jeszcze nie istnieją
ORMBaseModel.metadata.create_all(bind=db_engine)

# Endpointy (Zmodyfikuj je w odpowiedni sposób, zgodnie z wybraną przez siebie tematyką)

@app.get("/")
def test():
    """
    Endpoint testowy, sprawdzający czy aplikacja działa.
    """
    return {"message": "Witoj hopie!"}
    
@app.get("/people/{person_id}/position")
def get_position(person_id: int, db_session: Session = Depends(get_db_session)):
    """
    Endpoint do pobierania pozycji osoby o danym ID.
    
    Argumenty:
    - person_id: ID osoby (int)
    - db: Sesja bazy danych (zależność)

    Zwraca:
    - Współrzędne X i Y
    
    Depends - wstrzykiwanie zależności
    """
    # Pobieramy osobę z bazy danych
    person = db_session.query(Person).filter(Person.id == person_id).first()
    if not person:
        raise HTTPException(status_code=404, detail="Person not found")
    # Konwertujemy binarną reprezentację geometrii (well-known binary) na obiekt Shapely
    position_geom = wkb.loads(bytes(person.position.data))
    return {
        "position": {
            "x": position_geom.x,
            "y": position_geom.y
        }
    }
    
@app.put("/people/{person_id}/position")
def update_position(person_id: int, position_update: PositionUpdate, db_session: Session = Depends(get_db_session)):
    """
    Endpoint do aktualizacji pozycji osoby.

    Argumenty:
    - person_id: ID osoby
    - position_update: Obiekt zawierający nową pozycję (Pydantic)
    - db: Sesja bazy danych

    Zwraca:
    - Komunikat potwierdzający aktualizację
    """
    # Szukamy osoby w bazie
    person = db_session.query(Person).filter(Person.id == person_id).first()
    if not person:
        raise HTTPException(status_code=404, detail="Person not found")
    # Aktualizujemy pozycję w formacie WKT z odpowiednim SRID
    person.position = f"SRID=2180;{position_update.position}"
    # Zatwierdzamy zmiany w bazie danych
    db_session.commit()
    # Odświeżamy obiekt w sesji – pobieramy najnowsze dane z bazy
    db_session.refresh(person)
    return {
        "message": "Position updated",
        "id": person.id,
        "position": position_update.position
    }
    
# Dodaj trzy brakujące endpointy umożliwiające: dodawanie nowego obiektu, usuwanie obiektu, pobieranie wszystkich obiektów             

5. Dodaj plik __init__.py w tym samym katalogu, w którym znajdują się wszystkie dotchczas utworzone pliki

*********************************************************************************************************
Baza wiedzy
*********************************************************************************************************

*** O architekturze w duuuuuużym skrócie :)

Architektura klient-serwer to model komunikacji w systemach komputerowych, w którym klient (użytkownik lub aplikacja) żąda usług od serwera (komputer lub aplikacja dostarczająca te usługi). Jest to jeden z najczęściej stosowanych modeli w sieciach komputerowych, aplikacjach webowych, bazach danych i wielu innych systemach.

W architekturze P2P każdy węzeł w sieci pełni rolę zarówno klienta, jak i serwera. Węzły komunikują się bezpośrednio ze sobą, bez centralnego serwera.

Mikroserwisy to podejście do projektowania aplikacji jako zestawu małych, niezależnych usług, które komunikują się ze sobą przez API.

W architekturze sterowanej zdarzeniami systemy reagują na zdarzenia, które mogą być generowane przez użytkowników, systemy lub inne źródła.

W architekturze serverless aplikacje są uruchamiane w środowisku chmurowym, gdzie zarządzanie serwerami jest abstrahowane przez dostawcę usług chmurowych.

***

dekorator - specjalna funkcja w Pythonie, która pozwala na modyfikowanie lub rozszerzanie funkcjonalności innej funkcji lub metody bez zmiany 
jej kodu. Dekoratory są często używane do dodawania funkcji takich jak logowanie, walidacja, autoryzacja itp. Dekorator jest oznaczany przez 
symbol @ przed nazwą funkcji dekorującej. Więcej szczegółów: https://docs.python.org/3/glossary.html#term-decorator

Przykład:

def my_decorator(func):
    def wrapper():
        print("Coś przed funkcją")
        func()
        print("Coś po funkcji")
    return wrapper

@my_decorator
def say_hello():
    print("Hello!")

say_hello()

****

Aplikację FastAPI należy uruchomi za pomocą serwera ASGI, takiego jak Uvicorn.

****

ASGI (Asynchronous Server Gateway Interface) - specyfikacja interfejsu między serwerem a klientem, która uwzględnia asynchroniczne 
programowanie. ASGI jest następcą WSGI (Web Server Gateway Interface). Więcej szczegółów: https://asgi.readthedocs.io/en/latest/

***

***

Idea wzorca Factory - Umożliwienie wielokrotnego tworzenia obiektów (np. sesji) z tą samą konfiguracją (w sposób prosty, czysty i powtarzalny). Tworzenie obiektów bez ujawniania logiki ich tworzenia i konfiguracji.

***

yield -  słowo kluczowe w Pythonie, które zatrzymuje funkcję i zwraca wartość, ale nie kończy jej działania. Taka funkcja nazywa się generatorem. Można potem ją wznawiać i dalej kontynuować (tak, jakby była "pauzowana"). 

Typowe zastosowania yield:
- Zwracanie wielu wartości po kolei (leniwe przetwarzanie, nie wszystko na raz)
- Czytanie plików linia po linii
- Strumieniowanie danych (np. z API, bazy, socketów)
- Szybsze i mniej pamięciożerne przetwarzanie

Więcej szczegółów: https://docs.python.org/3/reference/expressions.html#yield-expressions

***
